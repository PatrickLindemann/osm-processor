Algorithm 1: Ring Creation Algorithm
Input: List[Way] ways
Output List[Ring];

List[Ring] rings = [];
while (!ways.empty())
    Ring current_ring = [];
    // Retrieve the next unprocessed way and add its
    // nodes to the current ring
    Way way = ways.pop()
    ring.add_nodes(way.nodes());
    // Try to complete ring recursively
    boolean is_complete = complete_ring(current_ring&, ways);
    if (is_complete):
        rings.add(current_ring);
    else:
        // No ring could be formed with the current way,
        // simply ignore it
    end if;
end while;
return rings;

---

Algorithm 1A: Recursive Ring Completition
Input: Ring& ring, List[Way] ways
Output: boolean

// Check if ring is already complete
if (ring.first() == ring.last())
    // Check if ring is valid, i.e. not self-intersecting
    return is_valid(ring);
end if;

// Ring is incomplete, search for next way candidates
// that start or end with the last node of the current
// ring
List[Way] candidates = [];
for (Way way in ways)
    if (ring.end() == way.first())
        candidates.add(way);
    else if (ring.end() == way.end())
        candidates.add(reverse(way))
    end if;
end for;

// Try to complete the ring with the identified way
// candidates. If the ring cannot be completed with
// a candidate, use backtracking to try another one.
for (Way candidate in candidates)
    // Remove current candidate from the way list.
    ways.pop(candidate);
    // Add all way nodes except the first one, as it
    // is the same as the current last node of the
    // ring.
    ring.add_nodes(candidate.nodes() \ {candidate.start()})
    // Try to complete ring recursively
    bool is_complete = complete_ring(ring, ways);
    if (is_complete)
        return true;
    else
        // Ring could not be completed with the current
        // candidate, re-add it to the way list and try
        // the next one.
        ways.add(candidate);
    end if;
end for;

// Way could not be completed
return false;

---

Algorithm 2: Ring Grouping Algorithm
Input List<InnerRing> inner_rings, List<OuterRing> outer_rings
Output: List<Pair<Outer, Inner>>

List<Pair<Outer, Inner>> pairs = [];

if (inner_rings.size() == 0)
    // Simple case: N outers, 0 inners
    // No grouping needs to be performed
    for (OuterRing outer in outer_rings)
        pairs.add(<Outer, null>);
else
    // Complex case: N outers, N inners
    // Perform ring grouping algorithm
    for (InnerRing inner in inner_rings)
        for (OuterRing outer in outer_rings)
            // Check if inner ring is contained within
            // the outer ring
            if (ring_in_ring(inner, outer))
                pairs.add(<outer, inner>);
                continue;
            end if;
        end for;
        // Inner ring was not assigned to an outer ring.
        // This happens if
        //  1) the inner ring is invalid (intersects with any outer ring) or
        //  2) the inner ring is actually an outer ring.
        // For either case, we ignore this ring.
    end for;
end if;

return pairs;

Algorithm 2A: Ring-In-Ring Test Algorithm (Modified Bentley-Ottoman)
Input: InnerRing inner, OuterRing outer
Output: boolean

// Check if the bounding box of the inner
// ring is contained in the outer bounding box
// first
inner_bounds = envelope(inner);
outer_bounds = envelope(outer);
if (rectangle_in_rectangle(inner, outer))

    // TODO actual algorithm
    return true;

end if;

return false;

---

// Note: Eine area kann in max. einer höheren Area liegen
// -> Alle outer vom area müssen in höherer area liegen

Algorithm 3: Area-Grouping-Algorithm
Input: Area child, List<Area> parents
Output: Area

child_bounds = envelope(child);

// Find parent candidates
candidates = []
for (Area parent in parents):
    parent_bounds = envelope(parent);
    if (rectangle_in_rectangle(parent)):
        candidates.add(parent);
    end if;
end for;

for (Area candidate in candidates)
    // Assert that each exclave of the child area
    // lies in an exclave of the parent candidate
    for (OuterRing child_outer in child.outer_rings())
        for (OuterRing parent_outer in parent.outer_rings())
            if (ring_in_ring(child_outer, parent_outer))
                // Assert that child exclave is not in a hole of the
                // parent exclave
                boolean in_hole = false;
                for (InnerRing parent_inner in parent.inner_rings())
                    if (ring_in_ring(child_outer, parent_inner))
                        // An exclave of the child area is contained
                        // in an inner hole of the parent exclave.
                        // -> Child exclave is not contained in this
                        // parent exclave.
                        in_hole = true;
                        break;
                    end if;
                end for;
                if (!in_hole)
                    // Child is contained in one parent exclave,
                    // therefore it 
                    return candidate;
                end if;
            end if;
        end for;
    end for;
end for;

// Child area could not be grouped to a parent.
return null;