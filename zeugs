        /**
         * 
         */
        bool outside_x_range(
            const Segment<double>& s1,
            const Segment<double>& s2
        ) noexcept {
            return s1.first().x() > s2.last().x();
        }

        /**
         * 
         */
        bool y_range_overlap(
            const Segment<double>& s1,
            const Segment<double>& s2
        ) noexcept {
            std::pair<double, double> m1 = std::minmax(s1.first().y(), s1.last().y());
            std::pair<double, double> m2 = std::minmax(s2.first().y(), s2.last().y());
            return !(m1.first > m2.second || m2.first > m1.second);
        }
        

            /**
             * 
             */
            inline void calculate_subareas()
            {
                // Create the hirarchy, which groups all areas to their level
                std::set<level_type> level_set;
                map_type<level_type> hirarchy;
                for (const Area& area : m_areas)
                {
                    auto it = hirarchy.find(area.level());
                    if (it == hirarchy.end())
                    {
                        it = hirarchy.insert(it, { area.level(), {} });
                    }
                    it->second.push_back(area.id());
                    level_set.insert(area.level());
                }
                if (level_set.size() == 1)
                {
                    // Only areas with one type of level were extracted,
                    // no subarea relations are possible
                    return;
                }

                // Calculate the envelopes for all areas
                std::vector<geometry::Rectangle> envelopes;
                for (const Area& area : m_areas)
                {
                    envelopes.push_back(functions::envelope(area, m_nodes));
                }

                // Iterate the level pairs
                std::vector<level_type> levels(level_set.size());
                std::copy(level_set.begin(), level_set.end(), levels.begin());
                for (size_t i = 0, j = 1; j < levels.size(); i++, j++)
                {
                    level_type high_level = levels.at(i);
                    level_type low_level = levels.at(j);

                    // Retrieve the area references for the current two levels
                    std::vector<id_type>& high_areas = hirarchy.at(high_level);
                    std::vector<id_type>& low_areas = hirarchy.at(low_level);

                    // Prepare the subarea map for the high areas
                    for (const id_type& high_ref : high_areas)
                    {
                        m_subareas[high_ref] = {};
                    }      

                    // Determine the subarea relations
                    for (const id_type& low_ref : low_areas)
                    {
                        // Find bonus candidates by checking if the lower
                        // area bounding box is contained in the higher area
                        // bounding box
                        std::vector<id_type> candidates;
                        for (const id_type& high_ref : high_areas)
                        {
                            if (functions::rectangle_in_rectangle(
                                envelopes.at(low_ref),
                                envelopes.at(high_ref)
                            )) {
                               candidates.push_back(high_ref);
                            }
                        }
                        // Find the bonus by polygon-in-polygon tests
                        for (const id_type& candidate : candidates)
                        {
                            //if (area_in_area(low_ref, candidate))
                            //{
                                m_subareas.at(candidate).push_back(low_ref);
                                break;
                            //}
                        }
                        // No bonus was found for the current area
                    }

                    // Verify that every higher area has at least one subarea
                    for (const id_type& high_ref : high_areas)
                    {
                        assert(m_subareas.at(high_ref).size() > 0);
                    }

                }

            }